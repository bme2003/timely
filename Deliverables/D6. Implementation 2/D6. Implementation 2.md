# D6. Implementation 2

_Group 02 - "Timely"_\
_Group Members: Brody England, Christian Butler, Dylan Hyer, Ian Nieto, Nyle Huntley, Sofia Mendoza_

## 1. Introduction
Timely is a web application designed to simplify scheduling and collaboration for university students juggling busy academic and social lives. From study group organizers to overwhelmed undergraduates trying to keep track of deadlines, Timely helps users stay on top of their commitments. Without a tool like Timely, students can struggle to find mutually available times for group meetings or effectively coordinate schedules. Timely's primary goal is to make scheduling effortless and collaborative, so students can focus on what matters mostâ€”learning and succeeding together.

Timely offers three key features: study group management, calendar synchronization, and communication tools. The study group management feature allows users to create and join study groups, set up meetings, and aggregate schedules to find the best times to meet. Calendar synchronization integrates directly with platforms like Canvas, letting students import their class schedules and assignments seamlessly. Finally, the communication tools include messaging and file sharing, which enable students to exchange important resources and stay connected with their peers. Together, these features foster a collaborative environment, helping students save time, reduce stress, and maximize productivity.

With Timely, university students can turn scheduling chaos into organized success.

https://github.com/bme2003/timely

## 2. Implemented requirements
# Implemented Requirements

Below is the documentation of implemented requirements for the current release of the `app.py` application, organized by the name of the team member who implemented them. Each entry includes the description of the requirement, associated GitHub issue, pull request, the implementer, approver, and screenshots where applicable.

## 1. Christian Butler

### Requirement: Add and manage calendar events to organize my schedule effectively.
- **Issue**: Event Management and Scheduling (Priority: 9, Hours: 8)
- **Pull Request**: Integrated calendar event creation and management
- **Implemented by**: Christian Butler
- **Approved by**: Ian Nieto
- **Screenshot**: *(Placeholder: Screenshot of event creation feature in action)*

### Requirement: Securely log in and manage my profile.
- **Issue**: Secure User Authentication and Profile Management (Priority: 8, Hours: 7)
- **Pull Request**: Added hashed password authentication and profile editing
- **Implemented by**: Christian Butler
- **Approved by**: Ian Nieto
- **Screenshot**: *(Placeholder: Screenshot of login and profile management features)*

---

## 2. Ian Nieto

### Requirement: Notifications for upcoming events to help stay organized.
- **Issue**: Notification System for Events (Priority: 7, Hours: 6)
- **Pull Request**: Implemented event reminder notifications
- **Implemented by**: Ian Nieto
- **Approved by**: Christian Butler
- **Screenshot**: *(Placeholder: Screenshot of notification system in action)*

### Requirement: Import external calendar files (e.g., iCalendar) to sync with my schedule.
- **Issue**: iCalendar File Import (Priority: 6, Hours: 5)
- **Pull Request**: Added functionality for importing iCalendar files
- **Implemented by**: Ian Nieto
- **Approved by**: Christian Butler
- **Screenshot**: *(Placeholder: Screenshot of iCalendar import feature)*

---

## 3. Dylan Hyer

### Requirement: Send and accept/decline friend requests to connect with classmates.
- **Issue**: Ability to quickly create, accept, or decline study invitations (Priority: 10, Hours: 6)
- **Pull Request**: Middle-end #94
- **Implemented by**: Dylan Hyer
- **Approved by**: Ian Nieto
- **Screenshot**: *(Placeholder: Screenshot of friend request feature in action)*

---

## 4. Nyle Huntley

### Requirement: Ensure secure data submissions with CSRF protection.
- **Issue**: Implementing CSRF Protection for Forms (Priority: 6, Hours: 4)
- **Pull Request**: Integrated CSRF protection for all form submissions
- **Implemented by**: Nyle Huntley
- **Approved by**: Ian Nieto
- **Screenshot**: *(Placeholder: Screenshot of CSRF protection in action)*

### Requirement: Provide error messages and feedback for invalid form submissions.
- **Issue**: Validation and Error Messaging (Priority: 7, Hours: 5)
- **Pull Request**: Added validation and user feedback for form errors
- **Implemented by**: Nyle Huntley
- **Approved by**: Christian Butler
- **Screenshot**: *(Placeholder: Screenshot of validation error message)*

---

## Notes
- All pull requests were reviewed and approved before merging.
- Screenshots are placeholders and should be replaced with actual images from the application.
- Follow-ups for any incomplete requirements or adjustments to the implementation will be handled in the next sprint cycle.

## 3. Tests

### 3.1 Unit tests
1. **Test framework:** Unittest and SQLAlchemy's built-in database testing

2. **Automated test file:** https://github.com/bme2003/timely/blob/main/tests/test_app.py

3. **Example test case:** The test_mocked_fetch_canvas_events test case creates a mock object consisting of data that might be pulled from a Canvas calendar event and ensures proper error handling by sending a request to the Canvas event importing endpoint, checking for a Canvas client error, and ensuring the error message displays properly.

4. **Result of automated test execution:**
Testing executed locally through cloned repository again; only newly added unit tests for Implementation 2 were ran here.

![Automated test execution](UnitTestingD6.png)

### 3.2 Acceptance tests

## 4. Demo

## 5. Code quality
Our team maintained high code quality for app.py by adopting several best practices and conventions. These ensured the code was robust, readable, and maintainable, while also facilitating team collaboration and minimizing errors. Here are the key aspects of what went well in the code:

1. **Clear and Self-Documenting Code**

Implementation: Variables, functions, and classes were named clearly to reflect their purpose. For example, fetch_canvas_events and validate_user_input describe their functionality at a glance.

Benefit: This made it easy for team members to understand the code without needing extensive comments or external documentation.

2. **Consistent Formatting**

Implementation: We adhered to consistent formatting throughout the file, including:

An 80-character line limit for readability.

Proper indentation and spacing.

Aligned brackets and clear separation of logical blocks.

Benefit: Consistent formatting improved code readability and ensured that all team members could easily navigate the file.

3. **Robust Error Handling**

Implementation: The application uses clear try-except blocks to handle errors gracefully, such as managing database connection issues or invalid user input.

Benefit: This ensured the application could recover from errors without crashing, providing a better user experience and simplifying debugging.

4. **Separation of Concerns**

Implementation: We followed modular design principles by separating logic into distinct functions and classes. For instance, database operations were managed through SQLAlchemy models, while route handling was confined to Flask route decorators.

Benefit: This made the codebase easier to test, debug, and extend, as changes in one part of the application did not inadvertently affect others.

5. **Use of Environment Variables**

Implementation: Sensitive information like secret keys and database URIs were stored in environment variables and loaded using dotenv.

Benefit: This enhanced security by keeping sensitive data out of the codebase, reducing the risk of exposure.

6. **Secure User Authentication**

Implementation: Passwords were hashed using werkzeug.security before being stored in the database. CSRF protection was implemented using Flask-WTF.

Benefit: These measures safeguarded user data and protected against common security vulnerabilities like SQL injection and CSRF attacks.

7. **Integration with External Libraries**

Implementation: Libraries like icalendar and requests were used effectively to handle calendar imports and API calls.

Benefit: This reduced development time by leveraging proven, high-quality tools for complex tasks.

8. **Testing and Validation**

Implementation: Data input was validated at both the client and server levels. Additionally, unit tests were written to test critical components of the application.

Benefit: Validation and testing ensured that the code worked as intended and prevented unexpected behaviors during runtime.

9. **Database Management with SQLAlchemy**

Implementation: Database interactions were abstracted using SQLAlchemy models, allowing for clean and maintainable code.

Benefit: This eliminated the need for raw SQL queries, reducing the risk of SQL injection and improving code readability.

10. **Scalability and Maintainability**

Implementation: The use of Flask blueprints and modular components made it easier to scale the application and add new features.

Benefit: This approach supported future growth and simplified collaboration by maintaining a well-organized codebase.

## 6. Lessons learned
Our team learned the importance of starting deliverables earlier to reduce last-minute stress, prioritizing core functionalities like backend fixes over enhancements, and integrating testing throughout development to ensure reliability. Clearer role assignments and regular progress reviews improved task accountability, while better communication and feedback loops could further streamline future work. Moving forward, we will focus on these areas to enhance efficiency and deliver higher-quality results.
